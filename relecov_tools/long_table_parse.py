"""
=============================================================
HEADER
=============================================================
INSTITUTION: BU-ISCIII
AUTHOR: Luis D. Aranda Lillo
MAIL: laranda@isciii.es
VERSION: 0
CREATED: 31-5-2022
REVISED: 31-5-2022
REVISED BY: Luis Chapado
DESCRIPTION:

    Parse a csv file and save the results in a file

REQUIREMENTS:
    -Python

TO DO:

================================================================
END_OF_HEADER
================================================================
"""

from datetime import datetime
import json
import logging
import os.path
import sys
from pathlib import Path
import rich
import relecov_tools
from relecov_tools.config_json import ConfigJson


# from relecov_tools.rest_api import RestApi

log = logging.getLogger(__name__)
stderr = rich.console.Console(
    stderr=True,
    style="dim",
    highlight=False,
    force_terminal=relecov_tools.utils.rich_force_colors(),
)


class LongTableParse:
    """

    - parse_a_list_of_dictionaries() : returns generated_JSON
    - saving_file(generated_JSON)
    - parsing_csv() : It manages all this proccess:
       - calling first to parse_a_list_of_dictionaries() and then calling to saving_file()

    """

    def __init__(self, file_path=None, output_directory=None):
        if file_path is None:
            self.file_path = relecov_tools.utils.prompt_path(
                msg="Select the csv file which contains metadata"
            )
        else:
            self.file_path = file_path

        if not os.path.exists(self.file_path):
            log.error("Metadata file %s does not exist ", self.file_path)
            stderr.print("[red] Metadata file " + self.file_path + " does not exist")
            sys.exit(1)

        if not self.file_path.endswith(".csv"):
            log.error("Metadata file %s is not a csv file ", self.file_path)
            stderr.print(
                "[red] Metadata file " + self.file_path + " must be a csv file"
            )
            sys.exit(1)

        if output_directory is None:
            self.output_directory = relecov_tools.utils.prompt_path(
                msg="Select the output folder"
            )
        else:
            self.output_directory = output_directory
        Path(self.output_directory).mkdir(parents=True, exist_ok=True)

        config_json = ConfigJson()
        self.long_table_heading = config_json.get_configuration("long_table_heading")

    def saving_file(self, generated_JSON):
        """
        Save the list of dictionaries, generated by the parse_a_list_of_dictionaries() function ,
        to a json file, naming as "long_table_JSON_" + "current date" + ".json"

        Args:
            generated_JSON (a list of dictionaries)
        """
        date_now = datetime.now()
        file_name = "long_table_JSON_" + str(date_now) + ".json"
        complete_path = os.path.join(self.output_directory, file_name)
        with open(complete_path, "w") as fh:
            fh.write(generated_JSON)

    def parse_a_list_of_dictionaries(self):
        """_summary_
        This function generates a json file from the csv file entered by the user (long_table.csv).
         - It checks if the headers of both files are the same
         - It checks if both files contain the same number of fields
        Returns:
            A list of dictionaries in json format.
        """

        try:
            with open(self.file_path) as fh:
                lines = fh.readlines()

        except FileNotFoundError:
            stderr.print("[red]The file we're looking for... doesn't exist")
            sys.exit(1)

        list_of_dictionaries = []
        headings_from_csv = lines[0].strip().split(",")
        dict_index_of_heading = {}

        for heading in self.long_table_heading:
            dict_index_of_heading[heading] = self.long_table_heading.index(heading)

        # check if the headers of both files are the same
        for heading_csv in headings_from_csv:
            if heading_csv not in dict_index_of_heading:
                stderr.print("[red]Incorrect Format, fields don't match")
                sys.exit(1)

        # check if both files contain the same number of fields
        if len(self.long_table_heading) is len(headings_from_csv):

            for line in lines[1:]:
                data_dict_from_long_table = {}
                data_list = line.strip().split(",")

                data_dict_from_long_table["Chromosome"] = {
                    "chromosome": data_list[dict_index_of_heading["CHROM"]]
                }

                data_dict_from_long_table["Position"] = {
                    "pos": data_list[dict_index_of_heading["POS"]],
                    "nucleotide": data_list[dict_index_of_heading["ALT"]],
                }

                data_dict_from_long_table["Filter"] = {
                    "filter": data_list[dict_index_of_heading["FILTER"]]
                }

                data_dict_from_long_table["VariantInSample"] = {
                    "dp": data_list[dict_index_of_heading["DP"]],
                    "ref_dp": data_list[dict_index_of_heading["REF_DP"]],
                    "alt_dp": data_list[dict_index_of_heading["ALT_DP"]],
                    "af": data_list[dict_index_of_heading["AF"]],
                }

                data_dict_from_long_table["Gene"] = {
                    "gene": data_list[dict_index_of_heading["GENE"]]
                }

                data_dict_from_long_table["Effect"] = {
                    "effect": data_list[dict_index_of_heading["EFFECT"]],
                    "hgvs_c": data_list[dict_index_of_heading["HGVS_C"]],
                    "hgvs_p": data_list[dict_index_of_heading["HGVS_P"]],
                    "hgvs_p_1_letter": data_list[
                        dict_index_of_heading["HGVS_P_1LETTER"]
                    ],
                }

                data_dict_from_long_table["Variant"] = {
                    "ref": data_list[dict_index_of_heading["REF"]]
                }

                data_dict_from_long_table["Sample"] = {
                    "sample": data_list[dict_index_of_heading["SAMPLE"]]
                }

                list_of_dictionaries.append(data_dict_from_long_table)

            return json.dumps(list_of_dictionaries, indent=4)
        else:
            print(
                "[red]Incorrect format, the headers do not have the same number of fields"
            )
            sys.exit(1)

    def parsing_csv(self):
        """
        function called when using the relecov-tools long-table-parse function.
        """
        generated_json = self.parse_a_list_of_dictionaries()
        self.saving_file(generated_JSON=generated_json)
